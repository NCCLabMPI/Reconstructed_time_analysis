duration = c("0.5" = "500 ms",
"1" = "1000 ms",
"1.5" = "1500 ms"))
# define order of task relevance
all_event_table$task_relevance <- factor(all_event_table$task_relevance, levels = c("non-target", "irrelevant"))
# plot for onset - split by task-relevance
cdf_on = ggplot(all_event_table %>% filter(SOA_lock == 'onset'& z_RT_aud < 3), aes(x = z_RT_aud, color = as.factor(SOA))) +
stat_ecdf(geom = "step", size = 1) +
ylab("Cumulative Probability") +
labs(title = "Auditory reaction time distribution", tag = "B") +
#xlim(c(-2,3))+
scale_color_manual(values = c('red', 'blue', '#00b300', "orange"), name = 'SOA [ms]', labels=c('0', '116', '232', '466'))+
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(linetype = "solid"),
panel.background = element_blank(),
axis.text = element_text(color = "black", size = 15),
legend.text = element_text(size = 20),
legend.title = element_text(size = 20, face="bold"),
axis.title = element_blank(),
plot.title = element_text(size = 25, face="bold"),
plot.tag = element_text(size = 25, face="bold"),
strip.text = element_text(size = 20))+
facet_grid(SOA_lock ~ task_relevance, labeller = custom_labels)
cdf_on
# plot for offset - split by duration
cdf_off = ggplot(all_event_table %>% filter(SOA_lock == 'offset' & z_RT_aud < 3), aes(x = z_RT_aud, color = as.factor(SOA))) +
stat_ecdf(geom = "step", size = 1) +
ylab("Cumulative Probability") +
xlab("z-scored auditory reaction time") +
#  xlim(c(-2,3))+
scale_color_manual(values = c('red', 'blue', '#00b300', "orange"), name = 'SOA [ms]', labels=c('0', '116', '232', '466'))+
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(linetype = "solid"),
panel.background = element_blank(),
axis.text = element_text(color = "black", size = 15),
legend.text = element_text(size = 20),
legend.title = element_text(size = 20, face="bold"),
axis.title = element_text(size = 20, face="bold"),
plot.title = element_text(size = 25, face="bold"),
plot.tag = element_text(size = 25, face="bold"),
strip.text = element_text(size = 20))+
facet_grid(SOA_lock ~ duration, labeller = custom_labels)
cdf_off
# combine plots
fig5b = ggarrange(cdf_on, cdf_off, ncol = 1, nrow = 2, common.legend = TRUE, legend = "right")
print(fig5b)
# specify the file name for the SVG and png export
svg_filename = "exp1_fig5b.svg"
png_filename = "exp1_fig5b.png"
# save an SVG and png graphic
svg(svg_filename, width = width, height = height)
png(png_filename, width = width, height = height)
# single trial level (as preregistered)
# fit model
model1 = glmer(RT_aud ~ f_SOA*c_is_onset*c_task_relevant +
(1*f_SOA*c_is_onset*c_task_relevant | sub_id)+
(1*f_SOA*c_is_onset*c_task_relevant | f_duration),
family=Gamma(link="identity"), data=all_event_table)
summary(model1)
# get chisquare and p values
Anova(model1)
# residual plots for visual inspection
plot(fitted(model1),residuals(model1))
qqnorm(residuals(model1))
# get R square
rsq.glmm(model1)
# subject level model (mean of each cell for each subjects - no single trials) (not preregistered)
subj_data = all_event_table %>% group_by(f_SOA, c_is_onset, c_task_relevant, sub_id, f_duration) %>%
summarise(RT_mean = mean(RT_aud, na.rm = TRUE))
sub_model1 = glmer(RT_mean ~ f_SOA*c_is_onset*c_task_relevant +
(1*f_SOA*c_is_onset*c_task_relevant | sub_id)+
(1*f_SOA*c_is_onset*c_task_relevant | f_duration),
family=Gamma(link="identity"), data = subj_data)
summary(sub_model1)
# get chisquare and p values
Anova(sub_model1)
# get R square
rsq.glmm(sub_model1)
# sub analysis restricted to onset
onset_event_table = all_event_table %>% filter(SOA_lock == "onset")
# fit onset model
onset_model = glmer(RT_aud ~ f_SOA*c_task_relevant +
(1*f_SOA*c_task_relevant | sub_id) +
(1*f_SOA*c_task_relevant | f_duration),
family = Gamma(link="identity"), data = onset_event_table)
summary(onset_model)
# get chisquare and p values
Anova(onset_model)
# get R square
rsq.glmm(onset_model)
# sub analysis restricted to offset
offset_event_table = all_event_table %>% filter(SOA_lock == "offset")
# fit offset model
offset_model = glmer(RT_aud ~ f_SOA*f_duration*c_task_relevant +
(1*f_SOA*f_duration*c_task_relevant | sub_id),
family = Gamma(link="identity"), data = offset_event_table)
summary(offset_model)
# get chisquare and p values
Anova(offset_model)
# get R square
rsq.glmm(offset_model)
# post-hoc bonferroni corrected pairwise comparison
em1 <- emmeans(offset_model, "f_SOA", by = "f_duration")
contrast(em1, "pairwise", adjust = "bonferroni")
# with duration, category and pitch as random effects
ctr_model = glmer(RT_aud ~ f_SOA*c_is_onset*c_task_relevant +
(1*f_SOA*c_is_onset*c_task_relevant | sub_id) +
(1*f_SOA*c_is_onset*c_task_relevant | f_duration) +
(1*f_SOA*c_is_onset*c_task_relevant | c_pitch) +
(1*f_SOA*c_is_onset*c_task_relevant | category),
family=Gamma(link="identity"), data=all_event_table)
summary(ctr_model)
# get chisquare and p values
Anova(ctr_model)
# get R square
rsq.glmm(ctr_model)
# compare control_model with main model
anova(model1, ctr_model)
# make task relevance and SOA lock numeric
acc_event_table = raw_event_table %>% mutate(is_task_relevant = ifelse(task_relevance == 'non-target',1,0))
acc_event_table = acc_event_table %>% mutate(is_onset = ifelse(SOA_lock == 'onset',1,0))
# make SOA and duration factors
acc_event_table = acc_event_table %>% mutate(f_SOA = factor(SOA, ordered = TRUE, levels = c("0", "0.116", "0.232", "0.466")))
acc_event_table = acc_event_table %>% mutate(f_duration = factor(duration, ordered = TRUE, levels = c("0.5", "1", "1.5")))
# center variables
acc_event_table = acc_event_table %>% mutate(c_task_relevant = is_task_relevant - mean(is_task_relevant))
acc_event_table = acc_event_table %>% mutate(c_is_onset = is_onset - mean(is_onset))
acc_event_table = acc_event_table %>% mutate(c_SOA = SOA - mean(SOA))
acc_event_table = acc_event_table %>% mutate(c_duration = duration - mean(duration))
# remove targets
acc_event_table = acc_event_table %>% filter(task_relevance != 'target')
acc_model = glmer(trial_accuracy_aud ~ f_SOA*c_is_onset*c_task_relevant +
(1*f_SOA*c_is_onset*c_task_relevant | sub_id)+
(1*f_SOA*c_is_onset*c_task_relevant | f_duration),
family = binomial, data=acc_event_table)
summary(acc_model)
Anova(acc_model)
# accuracy plot as RT plot
acc_data = raw_event_table %>% group_by(onset_SOA,SOA_lock, duration, sub_id, task_relevance) %>%
summarise(acc_mean = mean(trial_accuracy_aud, na.rm = TRUE))
acc_data  = acc_data  %>%  group_by(onset_SOA, SOA_lock,duration, task_relevance) %>%
summarise(mean_acc = mean(acc_mean, na.rm = TRUE),
sd_acc = sd(acc_mean, na.rm = TRUE),
sem_acc = sd_acc / sqrt(n))
# remove NaNs from auditory responses
acc_data  = acc_data [!is.na(acc_data $mean_acc), ]
# define order
acc_data $task_relevance = factor(acc_data $task_relevance,
levels = c('target', 'non-target', 'irrelevant'),
labels = c('Target', 'Relevant non-target', 'Irrelevant non-target'))
fig_S1 = ggplot(data = acc_data , aes(x = onset_SOA * 1000, y = mean_acc, group = interaction(as.character(duration), SOA_lock), color = as.character(duration), linetype = SOA_lock)) +
geom_line(linewidth = 1) +
geom_errorbar(aes(ymin = (mean_acc - sem_acc), ymax = (mean_acc + sem_acc)), width = 30, linewidth = 1) +
geom_point(size = 1.5) +
facet_grid(. ~ task_relevance) +
labs(title = "Auditory accuracy by task-relevance") +
ylab("Auditory accuracy [%]") +
xlab('SOA to visual onset [ms]') +
scale_color_manual(values = c('darkviolet', 'darkorange', 'darkred'),
name = 'Duration [ms]',
labels = c('500', '1000', '1500')) +
scale_linetype_manual(values = c("solid", "longdash"),
name = 'SOA time-locked to',
breaks = c('onset', 'offset')) +
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(linetype = "solid"),
panel.background = element_blank(),
axis.text = element_text(color = "black", size = 15),
legend.text = element_text(size = 20),
legend.title = element_text(size = 20, face="bold"),
axis.title = element_text(size = 20, face="bold"),
plot.title = element_text(size = 25, face="bold"),
strip.text = element_text(size = 20))
fig_S1
# initialize varibales
effect_size_table = matrix(ncol = 6, nrow = 5)
rownames(effect_size_table) = c("Mean_SOA0", "Mean_SOA466", "PRP_size", "joined_SD", "Cohensd")
colnames(effect_size_table) = c("target", "non_target_onset", "irrelevant_onset", "offset_short", "offset_intermediate", "offset_long")
# mean of SOA = 0
effect_size_table[1, ] = c(mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'target') %>% pull(RT_aud), na.rm = TRUE),
mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(RT_aud), na.rm = TRUE),
mean(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(RT_aud), na.rm = TRUE),
mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 0.5) %>% pull(RT_aud), na.rm = TRUE),
mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1) %>% pull(RT_aud), na.rm = TRUE),
mean(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1.5) %>% pull(RT_aud), na.rm = TRUE))
# mean of SOA = 466
effect_size_table[2, ] = c(mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' & task_relevance == 'target' & duration == 1.5) %>% pull(RT_aud), na.rm = TRUE),
mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(RT_aud), na.rm = TRUE),
mean(target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(RT_aud), na.rm = TRUE),
mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 0.5) %>% pull(RT_aud), na.rm = TRUE),
mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1) %>% pull(RT_aud), na.rm = TRUE),
mean(all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1.5) %>% pull(RT_aud), na.rm = TRUE))
# PRP size
effect_size_table[3, ] = effect_size_table[1, ] - effect_size_table[2, ]
# joined SD
effect_size_table[4, ] = c(sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'target') %>% pull(RT_aud),target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' & task_relevance == 'target' & duration == 1.5) %>% pull(RT_aud))),
sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(RT_aud), target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'non-target') %>% pull(RT_aud))),
sd(c(target_event_table %>% filter(SOA == 0 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(RT_aud), target_event_table %>% filter(SOA == 0.466 & SOA_lock == 'onset' & task_relevance == 'irrelevant') %>% pull(RT_aud))),
sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 0.5) %>% pull(RT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 0.5) %>% pull(RT_aud))),
sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1) %>% pull(RT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1) %>% pull(RT_aud))),
sd(c(all_event_table %>% filter(SOA == 0 & SOA_lock == 'offset' & duration == 1.5) %>% pull(RT_aud), all_event_table %>% filter(SOA == 0.466 & SOA_lock == 'offset' &  duration == 1.5) %>% pull(RT_aud))))
# cohens d
effect_size_table[5, ] = (effect_size_table[1, ] - effect_size_table[2, ])/effect_size_table[4, ]
# details of subjects
subNums2 = c(105, 106, 108, 109, 110, 113, 114, 115, 118, 122) # 101 excluded, 122 is the same as participant 116 from experiment one
n2 = length(subNums2)
sessions2 = c(2,3)
Lab_ID = 'SX'
# experiment 2 will be refered to as task 'introspection'
task = 'introspection'
# initialize loop variables
count = 0
sub_ids = NaN
table_size = 1:n2*2
# loading the files
# loop through subject and session numbers
for (subNum in subNums2){
for (ses in sessions2){
count = count + 1
sub_ids[count] = paste0(Lab_ID, subNum)
# make folder and file name
sub_folder = paste0('sub-', Lab_ID, subNum)
ses_folder = paste0('ses-', ses)
file_name = paste0(sub_folder, '_', ses_folder, '_run-all_task-', task,'_events.csv')
# make file directory
setwd("..")
parent_dir = getwd()
setwd(wd)
file = file.path(parent_dir, 'Reconstructed_time_experiment', 'data', sub_folder, ses_folder, file_name)
# load file
event_table2 = read.csv(file)
# store table dimensions
table_size[count] = dim(event_table2 %>% filter(task_relevance != 'target'))[1]
# make format consistent
if ('X' %in% colnames(event_table2))
{event_table2$X <- NULL}
colnames(event_table2)[which(names(event_table2) == "has_repsonse_vis")] <- "has_response_vis"
colnames(event_table2)[which(names(event_table2) == "trial_repsonse_vis")] <- "trial_response_vis"
# add subject number and session column
event_table2 = event_table2 %>% mutate(sub_num = subNum)
event_table2 = event_table2 %>% mutate(ses = ses)
# z-score of iRT_vis and iRT_aud
event_table2 = event_table2 %>% mutate(z_iRT_vis = (iRT_vis-mean(iRT_vis))/sd(iRT_vis))
event_table2 = event_table2 %>% mutate(z_iRT_aud = (iRT_aud-mean(iRT_aud))/sd(iRT_aud))
# z-score of RT_vis and RTaud
event_table2 = event_table2 %>% mutate(z_RT_vis = (RT_vis-mean(RT_vis, na.rm = TRUE))/sd(RT_vis, na.rm = TRUE))
event_table2 = event_table2 %>% mutate(z_RT_aud = (RT_aud-mean(RT_aud, na.rm = TRUE))/sd(RT_aud, na.rm = TRUE))
# concatenate the tables
if ( exists('all_event_table2')){
all_event_table2 = rbind(all_event_table2, event_table2)
} else {
all_event_table2 = event_table2
}
}}
# details of subjects
subNums2 = c(105, 106, 108, 109, 110, 113, 114, 115, 116, 118) # 101 excluded, 122 is the same as participant 116 from experiment one
n2 = length(subNums2)
sessions2 = c(2,3)
Lab_ID = 'SX'
# experiment 2 will be refered to as task 'introspection'
task = 'introspection'
# initialize loop variables
count = 0
sub_ids = NaN
table_size = 1:n2*2
# loading the files
# loop through subject and session numbers
for (subNum in subNums2){
for (ses in sessions2){
count = count + 1
sub_ids[count] = paste0(Lab_ID, subNum)
# make folder and file name
sub_folder = paste0('sub-', Lab_ID, subNum)
ses_folder = paste0('ses-', ses)
file_name = paste0(sub_folder, '_', ses_folder, '_run-all_task-', task,'_events.csv')
# make file directory
file = file.path(bids_root, sub_folder, ses_folder, 'beh', file_name)
# load file
event_table2 = read.csv(file)
# store table dimensions
table_size[count] = dim(event_table2 %>% filter(task_relevance != 'target'))[1]
# make format consistent
if ('X' %in% colnames(event_table2))
{event_table2$X <- NULL}
colnames(event_table2)[which(names(event_table2) == "has_repsonse_vis")] <- "has_response_vis"
colnames(event_table2)[which(names(event_table2) == "trial_repsonse_vis")] <- "trial_response_vis"
# add subject number and session column
event_table2 = event_table2 %>% mutate(sub_num = subNum)
event_table2 = event_table2 %>% mutate(ses = ses)
# z-score of iRT_vis and iRT_aud
event_table2 = event_table2 %>% mutate(z_iRT_vis = (iRT_vis-mean(iRT_vis))/sd(iRT_vis))
event_table2 = event_table2 %>% mutate(z_iRT_aud = (iRT_aud-mean(iRT_aud))/sd(iRT_aud))
# z-score of RT_vis and RTaud
event_table2 = event_table2 %>% mutate(z_RT_vis = (RT_vis-mean(RT_vis, na.rm = TRUE))/sd(RT_vis, na.rm = TRUE))
event_table2 = event_table2 %>% mutate(z_RT_aud = (RT_aud-mean(RT_aud, na.rm = TRUE))/sd(RT_aud, na.rm = TRUE))
# concatenate the tables
if ( exists('all_event_table2')){
all_event_table2 = rbind(all_event_table2, event_table2)
} else {
all_event_table2 = event_table2
}
}}
# 116 and 122 are the same person - should have the same id
all_event_table2 = all_event_table2 %>% mutate(sub_num = ifelse(sub_num == 122, 116, sub_num))
all_event_table2 = all_event_table2 %>% mutate(sub_id = ifelse(sub_id == 'SX122','SX116', sub_id))
# store table without exclusion
raw_event_table2 = all_event_table2
# # remove false alarms
all_event_table2 = all_event_table2[all_event_table2$trial_response_vis != 'fa', ]
# make iRT of 0 a 1 (zeros cause errors in GLMM with gamma family)
all_event_table2$iRT_vis[all_event_table2$iRT_vis == 0] = 1
all_event_table2$iRT_aud[all_event_table2$iRT_aud == 0] = 1
# # remove RT < 100 ms
all_event_table2 = all_event_table2[all_event_table2$RT_aud > 0.1, ]
# add response window column
all_event_table2 = all_event_table2 %>% mutate(resp_window = (2-onset_SOA)+stim_jit )
# remove RTaud > mean response window for offset, long duration and long SOA (deviation from preregistration)
max_RT = mean(all_event_table2$resp_window[all_event_table2$SOA == 0.466 & all_event_table2$SOA_lock == 'offset' & all_event_table2$duration == 1.5], na.rm = TRUE)
all_event_table2 = all_event_table2[all_event_table2$RT_aud < max_RT, ]
# remove incorrect auditory responses
all_event_table2 = all_event_table2[all_event_table2$trial_accuracy_aud == 1, ]
# remove NaNs from auditory responses
all_event_table2 = all_event_table2[!is.na(all_event_table2$RT_aud), ]
# store table with targets
target_event_table2 = all_event_table2
# remove target trials from all_event_table
all_event_table2 = all_event_table2[all_event_table2$task_relevance != 'target', ]
# add log transformed column
all_event_table2 = all_event_table2 %>% mutate(log_RT_aud = log(RT_aud))
# make task relevance and SOA lock numeric
all_event_table2 = all_event_table2 %>% mutate(is_task_relevant = ifelse(task_relevance == 'non-target',1,0))
all_event_table2 = all_event_table2 %>% mutate(is_onset = ifelse(SOA_lock == 'onset',1,0))
# make SOA and duration factors
all_event_table2 = all_event_table2 %>% mutate(f_SOA = factor(SOA, ordered = TRUE, levels = c("0", "0.232", "0.466")))
all_event_table2 = all_event_table2 %>% mutate(f_duration = factor(duration, ordered = TRUE, levels = c("0.5", "1", "1.5")))
# center variables
all_event_table2 = all_event_table2 %>% mutate(c_task_relevant = is_task_relevant - mean(is_task_relevant))
all_event_table2 = all_event_table2 %>% mutate(c_is_onset = is_onset - mean(is_onset))
all_event_table2 = all_event_table2 %>% mutate(c_SOA = SOA - mean(SOA))
all_event_table2 = all_event_table2 %>% mutate(c_duration = duration - mean(duration))
all_event_table2 = all_event_table2 %>% mutate(c_iRT_vis = (iRT_vis - mean(iRT_vis))/1000)
all_event_table2 = all_event_table2 %>% mutate(c_pitch = (pitch-1050)/100) # makes pitches 0.5 for high and -0.5 for low
# after trials removal
print('number of onset trials after trial removal (incl: targets)')
sum(target_event_table2$SOA_lock == 'onset')
print('number of offset trials after trial removal (incl: targets)')
sum(target_event_table2$SOA_lock == 'offset')
# before
print('number of onset trials before trial removal (incl: targets)')
sum(raw_event_table2$SOA_lock == 'onset')
print('number of offset trials after trial removal (incl: targets)')
sum(raw_event_table2$SOA_lock == 'offset')
# difference
print('number of onset trials removed (excl: targets)')
sum(raw_event_table2$SOA_lock == 'onset' & raw_event_table2$task_relevance != 'target') - sum(all_event_table2$SOA_lock == 'onset')
print('number of offset trials removed (excl: targets)')
sum(raw_event_table2$SOA_lock == 'offset' & raw_event_table2$task_relevance != 'target') - sum(all_event_table2$SOA_lock == 'offset')
# relative trial removal w/o targets
print('perceptage of onset trials removed (excl: targets)')
(sum(raw_event_table2$SOA_lock == 'onset' & raw_event_table2$task_relevance != 'target') - sum(all_event_table2$SOA_lock == 'onset'))/sum(raw_event_table2$SOA_lock == 'onset' & raw_event_table2$task_relevance != 'target')
print('perceptage of offset trials removed (excl: targets)')
(sum(raw_event_table2$SOA_lock == 'offset' & raw_event_table2$task_relevance != 'target') - sum(all_event_table2$SOA_lock == 'offset'))/sum(raw_event_table2$SOA_lock == 'offset' & raw_event_table2$task_relevance != 'target')
# relative trial removal targets
print('perceptage of onset target trials removed')
(sum(raw_event_table2$SOA_lock == 'onset' & raw_event_table2$task_relevance == 'target') - sum(target_event_table2$SOA_lock == 'onset' & target_event_table2$task_relevance == 'target'))/sum(raw_event_table2$SOA_lock == 'onset' & raw_event_table2$task_relevance == 'target')
print('perceptage of offset target trials removed')
(sum(raw_event_table2$SOA_lock == 'offset' & raw_event_table2$task_relevance == 'target') - sum(target_event_table2$SOA_lock == 'offset' & target_event_table2$task_relevance == 'target'))/sum(raw_event_table2$SOA_lock == 'offset' & raw_event_table2$task_relevance == 'target')
perf2 = data.frame(matrix(ncol = 0, nrow = 1))
perf2$sub_num = 'NaN'
perf2$hits = NaN
perf2$misses = NaN
perf2$crs = NaN
perf2$fas = NaN
perf2$hit_rate = NaN
perf2$fa_rate = NaN
perf2$aud_acc = NaN
perf2$RT_aud = NaN
perf2$RT_vis = NaN
perf2$RT_aud_raw = NaN
perf2$RT_vis_raw = NaN
perf2 = perf2[-c(1), ]
for (sub_num in subNums) {
perf2 = perf2 %>% add_row(sub_num = as.character(sub_num),
hits = sum(raw_event_table2$trial_response_vis =='hit' & raw_event_table2$sub_num == sub_num),
misses = sum(raw_event_table2$trial_response_vis =='miss' & raw_event_table2$sub_num == sub_num),
crs = sum(raw_event_table2$trial_response_vis =='cr' & raw_event_table2$sub_num == sub_num),
fas = sum(raw_event_table2$trial_response_vis =='fa' & raw_event_table2$sub_num == sub_num),
hit_rate = hits/(hits+misses)*100,
fa_rate = fas/(fas+crs)*100,
aud_acc = mean(raw_event_table2$trial_accuracy_aud[raw_event_table2$sub_num == sub_num], na.rm = TRUE)*100,
RT_aud = mean(target_event_table2$RT_aud[target_event_table2$sub_num == sub_num], na.rm = TRUE)*1000,
RT_vis = mean(target_event_table2$RT_vis[target_event_table2$sub_num == sub_num], na.rm = TRUE)*1000,
RT_aud_raw = mean(raw_event_table2$RT_aud[raw_event_table2$sub_num == sub_num], na.rm = TRUE)*1000,
RT_vis_raw = mean(raw_event_table2$RT_vis[raw_event_table2$sub_num == sub_num], na.rm = TRUE)*1000)
}
# transfer hit rate and false alarm rate into accuracy
perf2 = perf2 %>% mutate(vis_acc = (hits + crs)/(hits + misses + crs + fas)*100)
# add mean and SD
perf2 = perf2 %>% add_row(sub_num = 'mean',
hits = mean(perf2$hits),
misses = mean(perf2$misses),
crs = mean(perf2$crs),
fas = mean(perf2$fas),
hit_rate = mean(perf2$hit_rate),
fa_rate = mean(perf2$fa_rate),
aud_acc = mean(perf2$aud_acc),
vis_acc = mean(perf2$vis_acc),
RT_aud = mean(perf2$RT_aud),
RT_vis = mean(perf2$RT_vis),
RT_aud_raw = mean(perf2$RT_aud_raw),
RT_vis_raw = mean(perf2$RT_vis_raw))
perf2 = perf2 %>% add_row(sub_num = 'sd',
hits = sd(perf2$hits[1:n2]),
misses = sd(perf2$misses[1:n2]),
crs = sd(perf2$crs[1:n2]),
fas = sd(perf2$fas[1:n2]),
hit_rate = sd(perf2$hit_rate[1:n2]),
fa_rate = sd(perf2$fa_rate[1:n2]),
aud_acc = sd(perf2$aud_acc[1:n2]),
vis_acc = sd(perf2$vis_acc[1:n2]),
RT_aud = sd(perf2$RT_aud[1:n2]),
RT_vis = sd(perf2$RT_vis[1:n2]),
RT_aud_raw = sd(perf2$RT_aud_raw[1:n2]),
RT_vis_raw = sd(perf2$RT_vis_raw[1:n2]))
# percentage of underestimation in RTaud
underest_RTaud = mean(all_event_table2$iRT_aud)/mean(all_event_table2$RT_aud*1000)
# correlation for auditory RT (fig 8a)
fig8a = ggscatter(target_event_table2 , x = "z_RT_aud", y = "z_iRT_aud",
add = "reg.line", conf.int = TRUE,
cor.coef = TRUE, cor.method = "pearson", cor.coef.size = 6)+
labs(title = "Estimation performance auditory task", tag = "B")+
xlab("Objective z-scored reaction time")+
ylab('Subjective z-scored decision time')+
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(linetype = "solid"),
panel.background = element_blank(),
axis.text = element_text(color = "black", size = 15),
legend.text = element_text(size = 20),
legend.title = element_text(size = 20, face="bold"),
axis.title = element_text(size = 20, face="bold"),
plot.title = element_text(size = 25, face="bold"),
plot.tag = element_text(size = 25, face="bold"))
# plot figure
print(fig8a)
# specify the file name for the SVG and png export
svg_filename = "exp1_fig8a.svg"
png_filename = "exp1_fig8a.png"
# save an SVG and png graphic
svg(svg_filename, width = width, height = height)
png(png_filename, width = width, height = height)
# correlation for auditory RT (fig 8b)
fig8b = ggscatter(target_event_table2 , x = "z_RT_vis", y = "z_iRT_vis",
add = "reg.line", conf.int = TRUE,
cor.coef = TRUE,  cor.method = "pearson", cor.coef.size = 6)+
labs(title = "Estimation performance visual task", tag = "A")+
xlab("Objective z-scored reaction time")+
ylab('Subjective z-scored decision time')+
theme_bw() +
theme(axis.line = element_line(colour = "black"),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.border = element_rect(linetype = "solid"),
panel.background = element_blank(),
axis.text = element_text(color = "black", size = 15),
legend.text = element_text(size = 20),
legend.title = element_text(size = 20, face="bold"),
axis.title = element_text(size = 20, face="bold"),
plot.title = element_text(size = 25, face="bold"),
plot.tag = element_text(size = 25, face="bold"))
# plot figure
print(fig8b)
# specify the file name for the SVG and png export
svg_filename = "exp1_fig8b.svg"
png_filename = "exp1_fig8b.png"
# save an SVG and png graphic
svg(svg_filename, width = width, height = height)
png(png_filename, width = width, height = height)
# take mean RTaud, iRTaud, and iRTvis for each condition and subjects
RTaud_table_fig8c = target_event_table2 %>% group_by(onset_SOA, SOA_lock, sub_id, task_relevance, duration) %>%
summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000,
iT_aud_mean = mean(iRT_aud, na.rm = TRUE),
iT_vis_mean = mean(iRT_vis, na.rm = TRUE))
# collapse across duration
RTaud_table_fig8c = RTaud_table_fig8c %>% mutate(duration = ifelse(SOA_lock == 'onset',0 , duration))
# take mean and standard deviation of RTaud, iRTaud, and iRTvis for each condition
RTaud_table_fig8c = RTaud_table_fig8c %>%  group_by(onset_SOA, SOA_lock, task_relevance, duration) %>%
summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
sd_RT = sd(RT_mean, na.rm = TRUE),
sem_RT = sd_RT/sqrt(n2),
mean_iT_aud = mean(iT_aud_mean, na.rm = TRUE),
sd_iT_aud = sd(iT_aud_mean, na.rm = TRUE),
sem_iT_aud = sd_iT_aud/sqrt(n2),
mean_iT_vis = mean(iT_vis_mean, na.rm = TRUE),
sd_iT_vis = sd(iT_vis_mean, na.rm = TRUE),
sem_iT_vis = sd_iT_vis/sqrt(n2))
# define order
RTaud_table_fig8c$task_relevance = factor(RTaud_table_fig8c$task_relevance , levels=c('target','non-target','irrelevant'))
# take mean RTvis for each condition and subjects
RTvis_table_fig8c = RTvis_table_fig8c %>% group_by(onset_SOA,SOA_lock, sub_id, task_relevance, duration) %>%
summarise(RT_mean_vis = mean(RT_vis, na.rm = TRUE))
