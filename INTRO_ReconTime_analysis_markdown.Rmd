---
title: "ReconTime_INTRO"
output: html_document
date: "2023-06-01"
---

# housekeeping

```{r huosekeeping}
# clear workspace
rm(list = ls())

wd = 'C:/Users/micha.engeser/Documents/GitHub/Reconstructed_time_analysis'
setwd(wd)
dir()

# get package manager package
if (!('pacman' %in% installed.packages()))
{install.packages("pacman")}
library(pacman)

# install all needed packages 

pacman::p_load('dplyr', 'ggdist', 'ggeffects', 'ggpubr', 'lme4', 'emmeans', 'rstatix', 'car', 'rsq', 'sjPlot', 'brms')

```


# loading files

```{r loading}
# details of subjects  
subNums = c(101, 105, 106, 109, 110, 113, 114, 115, 118, 122)
sessions = c(2,3)
Lab_ID = 'SX'
task = 'introspection'
count = 0
sub_ids = NaN

# loading the files 

for (subNum in subNums ){
  for (ses in sessions ){
count = count + 1
sub_ids[count] = paste0(Lab_ID, subNum)

sub_folder = paste0('sub-', Lab_ID, subNum)
ses_folder = paste0('ses-', ses)
file_name = paste0(sub_folder, '_', ses_folder, '_run-all_task-', task,'_events.csv')

setwd("..")
parent_dir = getwd()
setwd(wd)
file = file.path(parent_dir, 'Reconstructed_time_experiment', 'data', sub_folder, ses_folder, file_name)

# load file
event_table = read.csv(file)

# make format consistent
if ('X' %in% colnames(event_table))
{event_table$X <- NULL}

colnames(event_table)[which(names(event_table) == "has_repsonse_vis")] <- "has_response_vis"
colnames(event_table)[which(names(event_table) == "trial_repsonse_vis")] <- "trial_response_vis"

# add subject number and session column 
event_table = event_table %>% mutate(sub_num = subNum)
event_table = event_table %>% mutate(ses = ses)

# concatanate the tables
if ( exists('all_event_table')){
  all_event_table = rbind(all_event_table, event_table)
} else {
  all_event_table = event_table
}
}}

```

# apply trial exclusion

```{r trial_exclusion}

# without exclusion
raw_event_table = all_event_table

# remove false alarm 
all_event_table = all_event_table[all_event_table$trial_response_vis != 'fa', ]

# make iRT of 0 a 1
all_event_table$iRT_vis[all_event_table$iRT_vis == 0] = 1
all_event_table$iRT_aud[all_event_table$iRT_aud == 0] = 1

# remove RT < 100 ms
all_event_table = all_event_table[all_event_table$RT_aud > 0.1, ]

# remove incorrect auditory responses
# all_event_table = all_event_table[all_event_table$trial_accuracy_aud == 1, ]

# remove NaNs from auditory responses
all_event_table = all_event_table[!is.na(all_event_table$trial_accuracy_aud), ]

# with targets
target_event_table = all_event_table

# remove target trials 
all_event_table = all_event_table[all_event_table$task_relevance != 'target', ]

# check if any combination of condition (cell) has less than 30 trials 

task_relevance_lvl = c('non-target', 'irrelevant')
SOA_lock_lvl = c('onset', 'offset')
SOA_lvl = c(0,0.232,0.466)
duration_lvl = c(0.5,1,1.5)
sub_id_lvl = sub_ids


for (o in sub_id_lvl){
  for (i in SOA_lvl){
    for (ii in SOA_lock_lvl) {
      for (iii in task_relevance_lvl) {
        for (iv in duration_lvl) {
          
          cell_trials = sum(all_event_table$sub_id == o & all_event_table$SOA == i & all_event_table$SOA_lock == ii & all_event_table$task_relevance == iii & all_event_table$duration == iv, na.rm = TRUE)
          

          if(cell_trials < 15){
            cell_name = paste(i,ii,iii,iv,sep= '-')
            warning(paste0('Subject ',o,' has only ', cell_trials,' trials for cell: ', cell_name, '\n'))
          }
        }}}}}

```

# transfrom data

``` {r transform_data}

# add log transformed column
all_event_table = all_event_table %>% mutate(log_RT_aud = log(RT_aud))

# add response window column 
all_event_table = all_event_table %>% mutate(resp_window = (2-onset_SOA)+stim_jit )

# make task relevance and SOA lock numeric
all_event_table = all_event_table %>% mutate(is_task_relevant = ifelse(task_relevance == 'non-target',1,0)) 
all_event_table = all_event_table %>% mutate(is_onset = ifelse(SOA_lock == 'onset',1,0))

# make SOA and duration factors 
all_event_table = all_event_table %>% mutate(f_SOA = factor(SOA, ordered = TRUE, levels = c("0", "0.232", "0.466")))
all_event_table = all_event_table %>% mutate(f_duration = factor(duration, ordered = TRUE, levels = c("0.5", "1", "1.5")))

# center variables 
all_event_table = all_event_table %>% mutate(c_task_relevant = is_task_relevant - mean(is_task_relevant))
all_event_table = all_event_table %>% mutate(c_is_onset = is_onset - mean(is_onset))
all_event_table = all_event_table %>% mutate(c_SOA = SOA - mean(SOA))
all_event_table = all_event_table %>% mutate(c_duration = duration - mean(duration))
all_event_table = all_event_table %>% mutate(c_iRT_vis = (iRT_vis - mean(iRT_vis))/1000)
all_event_table = all_event_table %>% mutate(c_pitch = (pitch-1050)/100) # makes pitches 0.5 for high and -0.5 for low

```

# performance

``` {r perfromance}
perf = data.frame(matrix(ncol = 0, nrow = 1))
perf$sub_id = "NaN"
perf$hits = NaN
perf$misses = NaN
perf$crs = NaN 
perf$fas = NaN
perf$hit_rate = NaN 
perf$fa_rate = NaN
perf$aud_acc = NaN
perf$RT_aud = NaN
perf = perf[-c(1), ]

for (sub_id in sub_ids) {
perf = perf %>% add_row(sub_id = sub_id,
  hits = sum(raw_event_table$trial_response_vis =='hit' & raw_event_table$sub_id == sub_id),
  misses = sum(raw_event_table$trial_response_vis =='miss' & raw_event_table$sub_id == sub_id),
  crs = sum(raw_event_table$trial_response_vis =='cr' & raw_event_table$sub_id == sub_id),
  fas = sum(raw_event_table$trial_response_vis =='fa' & raw_event_table$sub_id == sub_id),
  hit_rate = hits/(hits+misses)*100,
  fa_rate = fas/(fas+crs)*100,
  aud_acc = mean(raw_event_table$trial_accuracy_aud[raw_event_table$sub_id == sub_id], na.rm = TRUE)*100,
  RT_aud = mean(raw_event_table$RT_aud[raw_event_table$sub_id == sub_id], na.rm = TRUE)*1000)
}

perf = perf %>% add_row(sub_id = 'mean',
  hits = mean(perf$hits),
  misses = mean(perf$misses),
  crs = mean(perf$crs),
  fas = mean(perf$fas),
  hit_rate = mean(perf$hit_rate),
  fa_rate = mean(perf$fa_rate),
  aud_acc = mean(perf$aud_acc),
  RT_aud = mean(perf$RT_aud))

perf = perf %>% add_row(sub_id = 'sd',
  hits = sd(perf$hits[1:10]),
  misses = sd(perf$misses[1:10]),
  crs = sd(perf$crs[1:10]),
  fas = sd(perf$fas[1:10]),
  hit_rate = sd(perf$hit_rate[1:10]),
  fa_rate = sd(perf$fa_rate[1:10]),
  aud_acc = sd(perf$aud_acc[1:10]),
  RT_aud = sd(perf$RT_aud[1:10]))

```

# plotting - objective RT 

```{R plotting_RT}

# make duration a string
event_table2 = all_event_table
event_table2$duration = as.character(event_table2$duration)
n = length(subNums)

### HISTOGRAMS

# split by duration
hist_2 = ggplot(event_table2, aes(x=RT_aud, fill=duration)) +
  geom_histogram(alpha=0.6, position='identity') + xlim(c(0,2)) + ggtitle("Duration histogram")
hist_2
# split by task relevance
hist_3 = ggplot(event_table2, aes(x=RT_aud, fill=task_relevance)) +
  geom_histogram(alpha=0.6, position='identity') + xlim(c(0,2)) + ggtitle("Task relevance histogram")
hist_3
# split by SOA-lock
hist_4 = ggplot(event_table2, aes(x=RT_aud, fill=SOA_lock)) +
  geom_histogram(alpha=0.6, position='identity') + xlim(c(0,2)) + ggtitle("SOA-lock histogram")
hist_4


### LINE PLOTS -  RT aud vs SOA by SOA_lock

# RT by duration 

SOA_SOA_lock_duration_subj_data = all_event_table %>% group_by(SOA, SOA_lock, duration, sub_id) %>%
                                      summarise(RT_mean = mean(RT_aud, na.rm = TRUE))

SOA_SOA_lock_duration_data = SOA_SOA_lock_duration_subj_data %>%  group_by(SOA, SOA_lock, duration) %>%
                                      summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
                                                         sd_RT = sd(RT_mean, na.rm = TRUE),
                                                         sem_RT = sd_RT / sqrt(n))

p2 = ggplot(data=SOA_SOA_lock_duration_data, aes(x=SOA*1000, y=mean_RT*1000, group=interaction(as.character(duration), SOA_lock), color=as.character(duration), linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT)*1000, ymax = (mean_RT+sem_RT)*1000), width = 20)+
  geom_point()+
  ylim(c(400,800))+
  ylab("Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue','green'))
p2

# by duration, extended time

SOA_SOA_lock_duration_subj_data2 = all_event_table %>% group_by(onset_SOA,SOA_lock, duration, sub_id) %>%
                                      summarise(RT_mean = mean(RT_aud, na.rm = TRUE))

SOA_SOA_lock_duration_data2 = SOA_SOA_lock_duration_subj_data2 %>%  group_by(onset_SOA, SOA_lock,duration) %>%
                                      summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
                                                         sd_RT = sd(RT_mean, na.rm = TRUE),
                                                         sem_RT = sd_RT / sqrt(n))

p22 = ggplot(data=SOA_SOA_lock_duration_data2, aes(x=onset_SOA*1000, y=mean_RT*1000, group=interaction(as.character(duration), SOA_lock), color=as.character(duration), linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT)*1000, ymax = (mean_RT+sem_RT)*1000), width = 20)+
  geom_point()+
  ylim(c(450,800))+
  ylab("Reaction time [ms]")+
  xlab('SOA to onset [ms]')+
  scale_color_manual(values=c('darkviolet','darkorange','darkred'), name = 'Duration [ms]', labels=c('500', '1000', '1500'))+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) 
p22


# RT by task-relevance

SOA_SOA_lock_task_relevance_subj_data = all_event_table %>% group_by(SOA, SOA_lock, task_relevance, sub_id) %>%
                                      summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000)

SOA_SOA_lock_task_relevance_data = SOA_SOA_lock_task_relevance_subj_data %>%  group_by(SOA, SOA_lock, task_relevance) %>%
                                      summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
                                                         sd_RT = sd(RT_mean, na.rm = TRUE),
                                                         sem_RT = sd_RT / sqrt(n))


p3 = ggplot(data=SOA_SOA_lock_task_relevance_data, aes(x=SOA*1000, y=mean_RT, group=interaction(task_relevance, SOA_lock), color=task_relevance, linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_point()+
  ylim(c(400,800))+
  ylab("Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('blue', 'red'), name = 'Task Relevance', labels=c('task-relevant non-target', 'irrelevant'), breaks=c('non-target', 'irrelevant'))+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) 
p3


# RT by task-relevance, with targets 

SOA_SOA_lock_task_relevance_subj_target_data = target_event_table %>% group_by(SOA, SOA_lock, task_relevance, sub_id) %>%
                                      summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000)

SOA_SOA_lock_task_relevance_target_data = SOA_SOA_lock_task_relevance_subj_target_data %>%  group_by(SOA, SOA_lock, task_relevance) %>%
                                      summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
                                                         sd_RT = sd(RT_mean, na.rm = TRUE),
                                                         sem_RT = sd_RT / sqrt(n))


p4 = ggplot(data=SOA_SOA_lock_task_relevance_target_data, aes(x=SOA*1000, y=mean_RT, group=interaction(task_relevance, SOA_lock), color=task_relevance, linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_point()+
  #ylim(c(400,900))+
  ylab("Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('lightgreen','blue', 'red'), name = 'Task Relevance', labels=c('target', 'task-relevant non-target', 'irrelevant'), breaks=c('target', 'non-target', 'irrelevant'))+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) 
p4

```

# plotting - iT 

```{R plotting_IT}


# for iRT
hist_5 = ggplot(data=event_table)+geom_histogram(aes(x=iRT_aud),col="red")+
geom_histogram(aes(x=iRT_vis),col="blue")
hist_5

# ITs and objective RT aud split by onset/offset

SOA_SOA_lock_subj_data = all_event_table %>% group_by(SOA, SOA_lock, sub_id) %>%
                                      summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000,
                                                iT_aud_mean = mean(iRT_aud, na.rm = TRUE),
                                                iT_vis_mean = mean(iRT_vis, na.rm = TRUE))

SOA_SOA_lock_data = SOA_SOA_lock_subj_data %>%  group_by(SOA, SOA_lock) %>%
                                      summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
                                                         sd_RT = sd(RT_mean, na.rm = TRUE),
                                                         sem_RT = sd_RT/sqrt(n),
                                                         mean_iT_aud = mean(iT_aud_mean, na.rm = TRUE),
                                                         sd_iT_aud = sd(iT_aud_mean, na.rm = TRUE),
                                                         sem_iT_aud = sd_iT_aud/sqrt(n),
                                                         mean_iT_vis = mean(iT_vis_mean, na.rm = TRUE),
                                                         sd_iT_vis = sd(iT_vis_mean, na.rm = TRUE),
                                                         sem_iT_vis = sd_iT_vis/sqrt(n))

p1 = ggplot(data=SOA_SOA_lock_data, aes(x=SOA*1000, y=mean_RT, group=SOA_lock, linetype = SOA_lock, color='objective RT')) +
  geom_line()+
  geom_point()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_line(aes(y=mean_iT_aud, group=SOA_lock, linetype = SOA_lock, color='IT aud'))+
  geom_point(aes(y=mean_iT_aud, group=SOA_lock, color='IT aud'))+
  geom_errorbar(aes(ymin = (mean_iT_aud-sem_iT_aud), ymax = (mean_iT_aud+sem_iT_aud), color='IT aud'), width = 20)+
  geom_line(aes(y=mean_iT_vis, group=SOA_lock, linetype = SOA_lock, color='IT vis'))+
  geom_point(aes(y=mean_iT_vis, group=SOA_lock, color='IT vis'))+
  geom_errorbar(aes(ymin = (mean_iT_vis-sem_iT_vis), ymax = (mean_iT_vis+sem_iT_vis), color='IT vis'), width = 20)+
  ylim(c(200,800))+
  ylab("Time [ms]")+
  xlab('SOA [ms]')+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
    theme_bw() +
  scale_color_manual(values=c('black', '#e600ac', 'darkgreen'), name = 'Measure', breaks=c('objective RT', 'IT aud', 'IT vis'))+
  theme(axis.line = element_line(colour = "black"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_rect(linetype = "solid"),
    panel.background = element_blank()) 
p1


# iRT aud by task-relevance

SOA_SOA_lock_task_relevance_subj_i_aud_data = all_event_table %>% group_by(SOA, SOA_lock, task_relevance, sub_id) %>%
                                      summarise(RT_mean = mean(iRT_aud, na.rm = TRUE))

SOA_SOA_lock_task_relevance_i_aud_data = SOA_SOA_lock_task_relevance_subj_i_aud_data %>%  group_by(SOA, SOA_lock, task_relevance) %>%
                                      summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
                                                         sd_RT = sd(RT_mean, na.rm = TRUE),
                                                         sem_RT = sd_RT / sqrt(n))


p4 = ggplot(data=SOA_SOA_lock_task_relevance_i_aud_data, aes(x=SOA*1000, y=mean_RT, group=interaction(task_relevance, SOA_lock), color=task_relevance, linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_point()+
  ylim(c(150,500))+
  ylab("Introspective auditory reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue'))
p4

# iRT vis by task-relevance

SOA_SOA_lock_task_relevance_subj_i_vis_data = all_event_table %>% group_by(SOA, SOA_lock, task_relevance, sub_id) %>%
                                      summarise(RT_mean = mean(iRT_vis, na.rm = TRUE))

SOA_SOA_lock_task_relevance_i_vis_data = SOA_SOA_lock_task_relevance_subj_i_vis_data %>%  group_by(SOA, SOA_lock, task_relevance) %>%
                                      summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
                                                         sd_RT = sd(RT_mean, na.rm = TRUE),
                                                         sem_RT = sd_RT / sqrt(n))


p5 = ggplot(data=SOA_SOA_lock_task_relevance_i_vis_data, aes(x=SOA*1000, y=mean_RT, group=interaction(task_relevance, SOA_lock), color=task_relevance, linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_point()+
  ylim(c(0,400))+
  ylab("Introspective visual reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue'))
p5


##  Regression of iRT and RT aud

# full data

ggscatter(target_event_table , x = "iRT_aud", y = "RT_aud",
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")


# mean of subject data
RT_iRT_data = target_event_table %>% group_by(sub_id) %>%
                                      summarise(mean_RT = mean(RT_aud, na.rm = TRUE),
                                                         mean_iRT = mean(iRT_aud, na.rm = TRUE))

ggscatter(RT_iRT_data, x = "mean_iRT", y = "mean_RT", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")


# iRT vis vs iRT aud
ggscatter(raw_event_table, x = "iRT_aud", y = "iRT_vis", color='sub_id',
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")


```

  ylab("Introspective visual reaction time [ms]")+
  xlab('SOA [ms]')+# rain cloud plot

```{r raincloud_plot}

source("R_rainclouds.R")

# prepare data 
n = length(subNums)

rp_data = all_event_table %>%  group_by(SOA, SOA_lock, sub_id) %>%
                                      summarise(mean_RT = mean(RT_aud, na.rm = TRUE),
                                                         sd_RT = sd(RT_aud, na.rm = TRUE))

sum_data = rp_data %>%  group_by(SOA, SOA_lock) %>%
                                      summarise(RT_mean = mean(mean_RT, na.rm = TRUE),
                                                         RT_median = median(mean_RT, na.rm = TRUE),
                                                         RT_sd = sd(mean_RT, na.rm = TRUE),
                                                         RT_sem = RT_sd / sqrt(n))

rp_data$SOAj = jitter(rp_data$SOA, amount = .005)


# define colors
fill_colors = c(rep("pink",5),rep("lightblue",5))
line_colors = c("onset" = "blue", "offset" = "red")

#Rainclouds for repeated measures, additional plotting options 

ggplot(rp_data, aes(x = SOA, y = mean_RT, fill = SOA_lock)) +
  # distribution plot
  geom_flat_violin(aes(fill = interaction(SOA_lock,SOA)),position = position_nudge(x = .02, y = 0), adjust = 1.5, trim = FALSE, alpha = .5, colour = NA)+ 
  # connecting individual data points (onset-locked)
  geom_line(data = rp_data %>% filter(SOA_lock =="onset"), aes(x=SOAj+.02, y = mean_RT, group=sub_id), color = 'lightblue',linetype = 1, size=0.1)+
  # connecting individual data points (offset-locked)
  geom_line(data = rp_data %>% filter(SOA_lock =="offset"), aes(x=SOAj+.02, y = mean_RT, group=sub_id), color = 'pink',linetype = 1, linewidth=0.1)+ 
  # individual data points (each subject)
  geom_point(aes(x = as.numeric(SOAj)+.02, y = mean_RT, colour = SOA_lock), size = 0.5, shape = 20) +
  # box plots
  geom_boxplot(aes(x = SOA, y = mean_RT, fill = interaction(SOA_lock,SOA)),outlier.shape = NA, alpha = .5, width = .02, colour = "black")+
  # error bars
  geom_errorbar(data = sum_data, aes(x = as.numeric(SOA)+.02, y = RT_mean, group = SOA_lock, colour = SOA_lock, ymin = RT_mean-RT_sem, ymax = RT_mean+RT_sem), width = .005)+ 
  # mean line
  geom_line(data = sum_data, aes(x = as.numeric(SOA)+.02, y = RT_mean, group = SOA_lock, colour = SOA_lock),linetype = 2, size=0.5)+
  # mean points
  geom_point(data = sum_data, aes(x = as.numeric(SOA)+.02, y = RT_mean, group = SOA_lock, colour = SOA_lock), shape = 18, size=1)+
  # adjust colors 
  scale_fill_manual(values=fill_colors )+scale_color_manual(values = line_colors)

ggsave('../figures/raincloud.png', width = 6, height = 4)


```

# box plot - introspective RT aud

```{r boxplot}

box_plot_data = all_event_table %>%  group_by(sub_id, SOA, SOA_lock, task_relevance, duration) %>% summarise(mean_RT = mean(iRT_aud, na.rm = TRUE), sd_RT = sd(iRT_aud, na.rm = TRUE))

colors = c(rep("red",3),rep("darkred",3),rep("green",3),rep("darkgreen",3),rep("blue",3),rep("darkblue",3),rep("yellow",3), rep("orange",3))

ggplot(box_plot_data, aes(SOA_lock, mean_RT, fill=interaction(duration, task_relevance, SOA))) +
  stat_boxplot(geom ='errorbar')+
  geom_boxplot() +
  scale_fill_manual(values=colors)

```

# main analysis - model 1 

```{r model1}

## general linear mixed effect model 1 

# fixed effects: SOA (ordinal), SOA-Lock (as c_is_onset,  numeric, centered), Task-relevance (as c_task_relevant, numeric, centered)
# random effects: Subject ID, Duration (ordinal)

# auditory 
aud_model1 = glmer(iRT_aud ~ f_SOA*c_is_onset*c_task_relevant +
                     (1*f_SOA*c_is_onset*c_task_relevant | sub_id)+
                     (1*f_SOA*c_is_onset*c_task_relevant | f_duration),
               family=Gamma(link="log"), data=all_event_table)

summary(aud_model1)
Anova(aud_model1)
plot(fitted(aud_model1),residuals(aud_model1))
qqnorm(residuals(aud_model1))
rsq.glmm(aud_model1)

#### Log instaed of identity function #####

# visual

vis_model1 = glmer(iRT_vis ~ f_SOA*c_is_onset*c_task_relevant +
                     (1*f_SOA*c_is_onset*c_task_relevant | sub_id)+
                     (1*f_SOA*c_is_onset*c_task_relevant | f_duration),
               family=Gamma(link="log"), data=all_event_table)

summary(vis_model1)
Anova(vis_model1)
plot(fitted(vis_model1),residuals(vis_model1))
qqnorm(residuals(vis_model1))
rsq.glmm(vis_model1)
```

# control model - model2

```{r model2}


# with duration, category and pitch as random effects 

model2 = glmer(iRT_aud ~ f_SOA*c_is_onset*c_task_relevant +
                     (1*f_SOA*c_is_onset*c_task_relevant | sub_id) +
                     (1*f_SOA*c_is_onset*c_task_relevant | f_duration) +
                     (1*f_SOA*c_is_onset*c_task_relevant | c_pitch) +
                     (1*f_SOA*c_is_onset*c_task_relevant | category), 
                   family=Gamma(link="log"), data=all_event_table)
summary(model2)
Anova(model2)
rsq.glmm(model2)

# compare the two models
anova(model1, model2)

```

# exploratory analayses - plots of pitch, category, orientation and performance

```{r control_plots}

# pitch  

SOA_SOA_lock_pitch_data = all_event_table %>%  group_by(SOA, SOA_lock, c_pitch) %>%
                                      summarise(mean_iRT = mean(iRT_aud, na.rm = TRUE),
                                                         sd_iRT = mean(iRT_aud, na.rm = TRUE))

pitch_plot = ggplot(data=SOA_SOA_lock_pitch_data, aes(x=SOA*1000, y=mean_iRT, group=interaction(as.character(c_pitch), SOA_lock))) +
  geom_line(aes(color=as.character(c_pitch), linetype = SOA_lock))+
  geom_point()+
  ylim(c(200,500))+
  ylab("Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue','green'))
pitch_plot


# category 

SOA_SOA_lock_category_data = all_event_table %>%  group_by(SOA, SOA_lock, category) %>%
                                      summarise(mean_iRT = mean(iRT_aud, na.rm = TRUE),
                                                         sd_iRT = mean(iRT_aud, na.rm = TRUE))

category_plot = ggplot(data=SOA_SOA_lock_category_data, aes(x=SOA*1000, y=mean_iRT, group=interaction(category, SOA_lock))) +
  geom_line(aes(color=category, linetype = SOA_lock))+
  geom_point()+
  ylim(c(200,500))+
  ylab("Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values=c('red','blue','green','orange'))
category_plot


```

# visual iRT specific analyses

```{r iRTvis}


# remove NaNs from auditory responses
task_event_table = raw_event_table[!is.na(all_event_table$trial_accuracy_aud), ]

task_mean_iRT_vis = task_event_table %>%  group_by(task_relevance, sub_id) %>%
                                      summarise(mean_iRT = mean(iRT_vis, na.rm = TRUE),
                                                         sd_iRT = mean(iRT_vis, na.rm = TRUE))

ggbarplot(task_mean_iRT_vis, x = "task_relevance", y = "mean_iRT", 
  add = c("mean_se", "jitter"), fill = "task_relevance")+
  ylab("Mean decision time [ms]")+
  xlab('Task-relevance')+
   theme(axis.text.x=element_blank(),
        axis.ticks.x=element_blank())+
  scale_fill_manual(values = c("red","blue","lightgreen"), name = 'Task Relevance', labels=c('irrelevant', 'task-relevant non-target', 'target'))



task_mean_iRT_vis_df <- data.frame(mean_iRT = task_mean_iRT_vis$mean_iRT, task_relevance = task_mean_iRT_vis$task_relevance) 

# t-test
iRT_aud_pwc <- task_mean_iRT_vis_df %>% 
  pairwise_t_test(
    mean_iRT ~ task_relevance, paired = TRUE,
    p.adjust.method = "bonferroni"
    )
iRT_aud_pwc

```

# how much does PRP effect depend on T1 variabitiy (see Marti et al 2010 and 2012)

```{r corretion IT vis and RT}

target_event_table = target_event_table %>% mutate(f_SOA = factor(SOA, ordered = TRUE, levels = c("0", "0.232", "0.466")))


c1 = ggscatter(target_event_table, x = "iRT_vis", y = "RT_aud",
   color = "SOA_lock", palette = "jco",
   add = "reg.line", conf.int = TRUE, cor.coef = TRUE, cor.method = "pearson") + stat_cor(aes(color = SOA_lock), label.y = c(2.6,2.4,2.2))
c1



# split by SOA and SOA_lock
c2a = ggplot(all_event_table[all_event_table$SOA_lock == 'onset', ], aes(x = iRT_vis, y = RT_aud*1000, color = f_SOA)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = f_SOA)) +
  xlab("Visual introspective decision time [ms]") +
  ylab("Objective auditory reaction time [ms]") +
  scale_color_manual(values = c("#4775d1", '#ffbf00', "#666666"), name = "SOA [ms]", labels = c("0", "232", "466")) +
  ggtitle("onset")+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 3000, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = f_SOA),label.y = c(2850,2700,2550), method = "pearson", show.legend = FALSE)

c2b = ggplot(all_event_table[all_event_table$SOA_lock == 'offset', ], aes(x = iRT_vis, y = RT_aud*1000, color = f_SOA)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = f_SOA)) +
  xlab("Visual introspective decision time [ms]") +
  ylab("Objective auditory reaction time [ms]") +
  scale_color_manual(values = c("#4775d1", '#ffbf00', "#666666"), name = "SOA [ms]", labels = c("0", "232", "466")) +
  ggtitle("offset")+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 3000, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = f_SOA),label.y = c(2850,2700,2550), method = "pearson", show.legend = FALSE)


ggarrange(c2a, c2b, ncol=2, common.legend = TRUE, legend="bottom")



# split by task-relevance and SOA_lock
c3a = ggplot(target_event_table[target_event_table$SOA_lock == 'onset', ], aes(x = iRT_vis, y = RT_aud*1000, color = task_relevance))+
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = task_relevance))+
  xlab("Visual introspective decision time [ms]")+
  ylab("Objective auditory reaction time [ms]")+
  scale_color_manual(values = c("#4775d1", '#ffbf00', "#666666"), name = "Task relevance ", labels = c("Irrelevant", "Non-target", "Target"))+
  ggtitle("onset")+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 3000, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = task_relevance),label.y = c(2850,2700,2550), method = "pearson", show.legend = FALSE)

c3b = ggplot(target_event_table[target_event_table$SOA_lock == 'offset', ], aes(x = iRT_vis, y = RT_aud*1000, color = task_relevance))+
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = task_relevance))+
  xlab("Visual introspective decision time [ms]")+
  ylab("Objective auditory reaction time [ms]")+
  scale_color_manual(values = c("#4775d1", '#ffbf00', "#666666"), name = "Task relevance ", labels = c("Irrelevant", "Non-target", "Target"))+
  ggtitle("offset")+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 3000, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = task_relevance),label.y = c(2850,2700,2550), method = "pearson", show.legend = FALSE)


ggarrange(c3a, c3b, ncol=2, common.legend = TRUE, legend="bottom")

```
# plot suggested by Stan
```{r}

# Create the scatter plot with regression lines
c2a = ggplot(all_event_table[all_event_table$SOA_lock == 'onset', ], aes(x = RT_aud*1000, y = iRT_aud, color = f_SOA)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = f_SOA)) +
  xlab("Objective auditory reaction time [ms]") +
  ylab("Auditory introspective decision time [ms]") +
  scale_color_manual(values = c("#0073c2", '#ffbf00', "#666666"), name = "SOA [ms]", labels = c("0", "232", "466")) +
  ggtitle("onset")+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 1500, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = f_SOA),label.y = c(1400,1300,1200), method = "pearson", show.legend = FALSE)

c2b = ggplot(all_event_table[all_event_table$SOA_lock == 'offset', ], aes(x = RT_aud*1000, y = iRT_aud, color = f_SOA)) +
  geom_point() +
  geom_smooth(method = "lm", se = TRUE, aes(group = f_SOA)) +
  xlab("Objective auditory reaction time [ms]") +
  ylab("Auditory introspective decision time [ms]") +
  scale_color_manual(values = c("#0073c2", '#ffbf00', "#666666"), name = "SOA [ms]", labels = c("0", "232", "466")) +
  ggtitle("offset")+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())+
  stat_cor(color = 'black', label.y = 1500, method = "pearson", show.legend = FALSE)+
  stat_cor(aes(color = f_SOA),label.y = c(1400,1300,1200), method = "pearson", show.legend = FALSE)


ggarrange(c2a, c2b, ncol=2, common.legend = TRUE, legend="bottom")


# binned RTaud vs IRTaud

bins = 1:30

ITaud_bin = data.frame(matrix(ncol = 0, nrow = 1))
ITaud_bin$bin = NaN
ITaud_bin$mean = NaN
ITaud_bin$sd = NaN
ITaud_bin = ITaud_bin[-c(1), ]

for (bin in bins){
  
  bin_table = all_event_table[all_event_table$RT_aud <= bin/10 & all_event_table$RT_aud >= (bin-1)/10, ]
  ITaud_bin = ITaud_bin %>% add_row(bin = bin*100, mean = mean(bin_table$iRT_aud),
  sd = sd(bin_table$iRT_aud))
  
}


ggplot(ITaud_bin, aes(x= factor(bin), y = mean)) +  
  geom_bar(stat = "identity", position = position_dodge()) + 
  geom_errorbar(aes(ymin = mean-sd, ymax = mean+sd)) +
  xlab("Objective auditory reaction time [ms]") +
  ylab("Auditory introspective decision time [ms]")


# median split

all_event_table = all_event_table %>% mutate(iRT_vis_speed = ifelse(iRT_vis <= median(iRT_vis), "fast","slow"))


ggbarplot(all_event_table, x = "f_SOA", y = "RT_aud", fill = "iRT_vis_speed", facet.by = "SOA_lock", position = position_dodge(0.9),
  add = c("mean_se"))+
  xlab("SOA [ms]") +
  ylab("Auditory reaction time [ms]") +
  scale_fill_manual(values = c("red","blue"), name = 'ITvis Speed', labels=c('fast', 'slow'))


SOA_SOA_lock_iRT1_speed_subj_data = all_event_table %>% group_by(SOA, SOA_lock, sub_id, iRT_vis_speed) %>%
                                      summarise(RT_mean = mean(RT_aud, na.rm = TRUE)*1000)

SOA_SOA_lock_iRT1_speed_data = SOA_SOA_lock_iRT1_speed_subj_data %>%  group_by(SOA, SOA_lock, iRT_vis_speed) %>%
                                      summarise(mean_RT = mean(RT_mean, na.rm = TRUE),
                                                         sd_RT = sd(RT_mean, na.rm = TRUE),
                                                         sem_RT = sd_RT / sqrt(n))


ggplot(data=SOA_SOA_lock_iRT1_speed_data, aes(x=SOA*1000, y=mean_RT, group=interaction(iRT_vis_speed, SOA_lock), color=iRT_vis_speed, linetype = SOA_lock)) +
  geom_line()+
  geom_errorbar(aes(ymin = (mean_RT-sem_RT), ymax = (mean_RT+sem_RT)), width = 20)+
  geom_point()+
  ylim(c(400,900))+
  ylab("Auditory Reaction time [ms]")+
  xlab('SOA [ms]')+
  scale_color_manual(values = c("darkgrey","black"), name = 'ITvis Speed')+
  scale_linetype_manual(values=c("solid", "dashed"), name = 'SOA time-locked to', breaks=c('onset', 'offset'))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank()) 


ggbarplot(all_event_table, x = "f_SOA", y = "RT_aud", fill = "iRT_vis_speed", facet.by = c("SOA_lock","iRT_vis_speed"), position = position_dodge(0.9),
  add = c("mean_se"))+
  xlab("SOA [ms]") +
  ylab("Auditory reaction time [ms]") +
  scale_fill_manual(values = c("pink","lightblue"), name = 'ITvis Speed', labels=c('fast', 'slow'))


model_T1speed = glmer(RT_aud ~ f_SOA*c_is_onset*c_task_relevant*iRT_vis_speed +
                     (1*f_SOA*c_is_onset*c_task_relevant*iRT_vis_speed | sub_id)+
                     (1*f_SOA*c_is_onset*c_task_relevant*iRT_vis_speed | f_duration),
               family=Gamma(link="identity"), data=all_event_table)

summary(model_T1speed)
Anova(model_T1speed)
plot(fitted(model_T1speed),residuals(model_T1speed))
qqnorm(residuals(model_T1speed))
rsq.glmm(model_T1speed)


model_T1 = glmer(RT_aud ~ f_SOA*c_is_onset*c_task_relevant*c_iRT_vis +
                     (1*f_SOA*c_is_onset*c_task_relevant*c_iRT_vis| sub_id)+
                     (1*f_SOA*c_is_onset*c_task_relevant*c_iRT_vis | f_duration),
               family=Gamma(link="identity"), data=all_event_table)

summary(model_T1)
Anova(model_T1)
plot(fitted(model_T1),residuals(model_T1))
qqnorm(residuals(model_T1))
rsq.glmm(model_T1)

```

# calibration performance

```{r calibration}

# loading the files 

for (subNum in subNums ){
  for (ses in sessions ){
count = count + 1
sub_ids[count] = paste0(Lab_ID, subNum)

sub_folder = paste0('sub-', Lab_ID, subNum)
ses_folder = paste0('ses-', ses)
file_name = paste0(sub_folder, '_', ses_folder, '_run-1_task-calibration_events.csv')

setwd("..")
parent_dir = getwd()
setwd(wd)
file = file.path(parent_dir, 'Reconstructed_time_experiment', 'data', sub_folder, ses_folder, file_name)

# load file
cali_table = read.csv(file)

# add subject number and session column 
cali_table = cali_table %>% mutate(sub_num = subNum)
cali_table = cali_table %>% mutate(sub_id = paste0(Lab_ID, subNum))
cali_table = cali_table %>% mutate(ses = ses)
cali_table = cali_table %>% mutate(estimation_error = -estimation_error)
cali_table = cali_table %>% mutate(abs_est_error = abs(estimation_error))
cali_table = cali_table %>% mutate(rel_est_error = abs_est_error/cali_ms)


# concatanate the tables
if ( exists('all_cali_table')){
  all_cali_table = rbind(all_cali_table, cali_table)
} else {
  all_cali_table = cali_table
}
  }}

# correlation estimated time and actual time 
ggscatter(all_cali_table, x = "cali_ms", y = "iT",
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")+
  ggtitle("Calibration performance")+
  xlab("Objective tones length [ms]") +
  ylab("Estimated time [ms]") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())


# correlation estimated time and actual time by subject 
ggscatter(all_cali_table, x = "cali_ms", y = "iT", color='sub_id',
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")+
  ggtitle("Calibration performance")+
  xlab("Objective tones length [ms]") +
  ylab("Estimated time [ms]") +
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())

# correlation absolute estimation error time and actual time 
ggscatter(all_cali_table, x = "cali_ms", y = "abs_est_error", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")

# correlation relative estimation error time and actual time 
ggscatter(all_cali_table, x = "cali_ms", y = "rel_est_error", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")

# correlation relative estimation error time and actual time 
ggscatter(all_cali_table, x = "cali_ms", y = "estimation_error", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson")+
  ggtitle("Calibration error")+
  xlab("Objective tones length [ms]") +
  ylab("Estimation error [ms]") +
  ylim(c(-750,500))+
  theme_bw() +
  theme(axis.line = element_line(colour = "black"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank(),
        panel.border = element_rect(linetype = "solid"),
        panel.background = element_blank())




```


# testing duration of experiment

```{r durations}

# duration of core experiment (3 blocks, no practice or calibration task)

# start counter 
ses_counter = 0
core_exp_time = NaN

# loops through subjects and sessions and extract duration 
for (sub_id in sub_ids){
  for (ses in sessions){
    
    ses_counter = ses_counter + 1
    test_table = raw_event_table[raw_event_table$sub_id == sub_id & raw_event_table$ses == ses, ]
    
    if(dim(test_table)[1] > 0){
    core_exp_time[ses_counter] = test_table$trial_end[dim(test_table)[1]] - test_table$TargetScreenOnset[1]
    }
    
  }}

print(paste0('Total duration of core experiment was ', round(mean(core_exp_time, na.rm = TRUE)/60), ' min. per session'))

print(paste0('Each miniblock was ', round(mean(core_exp_time, na.rm = TRUE)/60/12), ' min.'))

```
